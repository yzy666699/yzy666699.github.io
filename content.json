{"pages":[{"title":"About me","permalink":"https://yzy666699.github.io/about/index.html","text":"Binary Security researcher and malware development enthusiast C &#x2F;C艹 Java Go Telegram: @DB_Cooper_me Github： Y2Y Twttier: X Mail: &#x79;&#122;&#x79;&#54;&#54;&#54;&#54;&#x39;&#x39;&#64;&#103;&#x6d;&#105;&#x61;&#108;&#x2e;&#x63;&#x6f;&#x6d;"}],"posts":[{"title":"逆向分析","permalink":"https://yzy666699.github.io/2023/07/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","text":"逆向分析记一次对勒索病毒的分析知识汇总在PE（Portable Executable，可移植可执行）文件格式中，各种数据结构和表都是通过偏移量来访问的。特定的偏移量，如60和120，通常与PE文件的标准布局有关。具体来说： PE文件头结构：PE文件由MS-DOS头、PE文件头（包括COFF文件头和可选头）以及节（Sections）组成。PE头后面紧跟的是节表（Sections table），它描述了文件中各个节的位置和特性。 60偏移量：在PE文件中，从文件开始到PE标志的偏移量存储在MS-DOS头的0x3C位置（十进制为60）。这是一个指向PE头的指针。通过读取这个偏移量并加上基地址，可以定位到PE头的开始。 120偏移量：在可选头中，DataDirectory是一个数组，它提供了关于各种表和数据结构（如导入表、导出表、资源表等）的信息。DataDirectory的第一个元素（索引为0）是导出表的入口，而DataDirectory本身在可选头的开始处有一个偏移量。在标准的PE格式中，DataDirectory数组距离PE头的开始有0x78（十进制120）字节的偏移。 所以，当你看到这样的代码： 1234.text:004068F1 mov ecx, [edi+3Ch].text:004068F4 and esi, 1FFFFFh.text:004068FA xor ebx, ebx.text:004068FC mov ecx, [ecx+edi+78h] 1v14 + *(_DWORD *)(*(_DWORD *)(v14 + 60) + v14 + 120) 这里的操作可以这样理解： v14代表加载到内存中的PE文件的基地址。 v14 + 60是获取到PE头的偏移量。 *(_DWORD *)(v14 + 60)读取该偏移量，得到PE头的实际地址。 在PE头的基础上加上120，即可定位到DataDirectory。 最终，这段代码访问了PE文件中的某个特定DataDirectory入口（很可能是导出表），然后通过这个入口来获取其他信息或进行进一步的操作。 如果逆向时突然出现两次循环且每次循环次数都为256，后续存在异或操作基本可以猜测为rc4解密算法，这种特性为rc4算法特征 记一次BYOYD驱动分析首先直接定位到驱动的IRP_MJ_DEVICE_CONTROL(14)分发例程函数位置： a2-&gt;Tail.Overlay.CurrentStackLocation其实就是IoGetCurrentIrpStackLocation()函数的实现。 正常是通过stack-&gt;Parameters.DeviceIoControl.IoControlCode 来获取IOCTL值的，反编译这里是通过 CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart 获取，姑且当做是同一个意思。 alt+Y切换联合体 a2-&gt;AssociatedIrp.MasterIrp 其实是a2-&gt;AssociatedIrp.SystemBuffer（输入缓冲区的地址），因为它俩在一个union 中，共享一个偏移量。 Associatedlrp.SystemBuffer: SystemBuffer指针指向一个数据缓冲区，该缓冲区位于内核模式的非分页内存中I&#x2F;O管理器把用户模式程序发送给驱动程序的数据复制到这个缓冲区，这也是创建IRP过程的一部分。对于读请求，设备驱动程序把读出的数据填到这个缓冲区，然后I&#x2F;O管理器再把缓浊区的内容复制到用户模式缓冲区。 MasterIrp-&gt;Type 其实就是SystemBuffer 这个缓冲区（0x9E6A0594 代表这是一个缓冲IO），因为这里Type它的偏移其实是0。MasterIrp-&gt;MdlAddress这里的MdlAddress偏移是8，是一个长度（从sub_1400012BC函数内部看出来的），这个由客户端程序构造。 dword_14000410C是一个全局变量（在.data段），它的值是当前进程的PID，在sub_1400012BC函数中赋予。所以，我们要想走到下面的流程，必须要先完成0x9E6A0594 这个IOCTL的操作。 接下来看下面几个IOCTL对应的代码逻辑： 0xE6224248 这个IOCTL代码下面，可以见到是根据PID获取句柄，然后添加到I&#x2F;O缓冲区后面。此部分逻辑和内存读取无关。 0x60A26124 这块的代码逻辑，首先是从I&#x2F;O缓冲区中获取进程句柄。然后利用ObReferenceObjectByHandle 函数获取此句柄对应的EPROCESS结构，最后调用sub_140001B80函数。在这个函数中，发现了MmCopyVirtualMemory 虚拟内存拷贝函数。 接下来就是弄清楚，这个5个参数是如何组织的： 这里rdi寄存器中保存的是I&#x2F;O缓冲区的地址。结合上两张图I&#x2F;O缓冲区中的数据可以构成如下结构： 1234567struct&#123;HANDLE ProcessHander;INT64 SourceAddr;INT64 TargetAddr;SIZE_T Size;SIZE_T Result;&#125; 注意这里MmCopyVirtualMemory 函数的SourceProcess和TargetProcess都一样为当前进程的EPROCESS。所以这里SourceAddr和TargetAddr互换就可以实现读写效果。 记一次堆外挂的分析查壳Patch ida由于ida不支持中文名称命名，先patch掉中文函数名称支持 去除合法字符检测 ：合法字符的定义在ida.cfg文件中，我们定位到文件，搜索Block_CJK_Unified_Ideographs。注释掉即可 接触ida反汇编中文限制 过对IDA进行逆向得知，原来hexray在生成伪代码的时候会调用一个calc_c_cpp_name函数，该函数会试图针对C&#x2F;C++的函数名称进行优化，结果却误伤中文字符，我们将此处代码给NOP掉，就可以了。 采用插件分析易语言特征dump数据 手动搜索 4d 5a 90 搜索到两个pe特征 dump出数据 ​ 易语言开发通常会把PE文件当作图片资源存放在易语言资源里面，而资源的数据区上面的DWORD就是数据大小 按这个规律可以直接dump出两个PE文件 菜单栏中选择：edit–&gt;array，就会弹出如下的转换为数组，数组大小写入0x8660 菜单栏选择：edit-&gt;export data 选择raw格式 dump出的数据 dump1.sys 逆向 拖入ida分析，查看是标准的wdf驱动 分析IRP_MJ_DEVICE_CONTROL(14) 360 驱动逆向360文FsFlt.sys件系统过滤驱动"},{"title":"静态软件分析","permalink":"https://yzy666699.github.io/2023/05/06/%E9%9D%99%E6%80%81%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/","text":"静态软件分析part 0x01 Introductionadditionvalue不断的认识自己，发掘自己，明白什么东西使自己快乐起来，什么东西愿意花时间去搞，思考 security amply污点分析&#x2F;信息流分析&#x2F;数据流分析&#x2F;控制流分析&#x2F;过程间分析&#x2F;指针分析&#x2F;别名分析&#x2F;符号执行 内存泄露和空指针引用：如果一个指针被错误地使用（例如，被设为 null 或者指向已经释放的内存），程序可能会崩溃或者产生未定义的行为。指针分析可以帮助检测这类错误。 缓冲区溢出：如果一个指针被用来写入超过了预分配的内存区域，就可能导致缓冲区溢出，这是一种常见的安全漏洞。通过对指针的使用进行分析，我们可以找出可能的缓冲区溢出。 未授权的内存访问：如果一个指针被用来访问不应该被访问的内存区域（例如，其他用户的数据或者敏感的系统资源），这可能是一个安全问题。指针分析可以帮助我们发现这样的问题。 数据竞态条件：如果多个线程或者进程共享一段内存，并且对这段内存的访问没有被正确地同步，可能会导致数据竞态条件，这也是一种常见的安全问题。通过指针分析，我们可以确定哪些内存区域被多个线程或者进程共享，从而帮助我们找出可能的数据竞态条件。 fsadfsdf PL分支 语言的分类：命令式 (C, Java)、函数式 (Haskell)、逻辑式&#x2F;声明式 挑战：语言没有变，但是程序变复杂了，如何保证可靠 静态分析的用途：程序可靠性、程序安全、编译优化、程序理解 Static Analysis 静态分析 静态分析：Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P. 一句话概括静态分析：Static Analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed. 在保证正确性的前提下，在精度和速度上做平衡。 两个词概括静态分析 useful static analysis: 具体值-&gt;符号值 useful static analysis Transfer functions: 抽象值上的操作 ![teansfer function](&#x2F;images&#x2F;context&#x2F;teansfer function.png) Control flows ![contril flows](&#x2F;images&#x2F;context&#x2F;contril flows.png) sound &amp; complete Rice’s Theorem : Any non-trivial property of the behavior of programs in a r.e. language is undecidable. non-trivial properties ~&#x3D; interesting properties ~&#x3D; the properties related with run-time behaviors of programs r.e. (recursively enumerable) 递归可枚举语言: recognizable by a Turing-machine There is no such approach to determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No 故不存在 perfect (sound &amp; complete) static analysis useful static analysis Over- and under-approximations are both for safety of analysis sound: 报出所有问题 may analysis: outputs information that may be true (over-approximation) (safe&#x3D;over) complete: 报出的问题都是对的 must analysis: outputs information that must be true (under-approximation) (safe&#x3D;under) useful static analysis 妥协 soundness (false negatives 可能漏报) 妥协 completeness (false positives 可能误报) (大多数情况的分析，因为 soundness 很重要) part 0x02 Control Flow Graphspart 0x03 Data Flow Analysis迭代算法"},{"title":"AI制作图片二维码","permalink":"https://yzy666699.github.io/2022/08/11/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%88%B6%E4%BD%9C/","text":"AI制作图片二维码二维码解析将二维码转换成矢量图，并采用在线网站进行二维码解析 二维码生成矢量图https://qrcode.antfu.me/ 进行参数调节 ssh连接webui1ssh -CNg -L 6006:127.0.0.1:6006 root@222.187.226.110 -p 31146 二维码webui生成主模型revAnimated prompt风景正向词 british columbia, surrounded by mountains and nature, beautiful lakes and rivers, northern lights, volumetric lighting, photorealistic, insanely detailed and intricate, canadian rocky mountains, 8k ultra hd, matte painting, night time, Sweeper3D, Ultra realistic, (35mm style:1. 1), ((best quality)), ((masterpiece)), ((realistic)), radiant light rays, highres, highly detailed, concept art, Exaggeration, Aesthetic, magazine, Backlight, light color , heavenly, shadowy, Realism, octane render, unreal engine 5, Shaders, Denoise, De-Noise, Ambient Occlusion 反向词 (bad-image-v2-39000:0.8), (bad_prompt_version2:0.8), (bad-hands-5:1.1), (EasyNegative:0.8), (NG_DeepNegative_V1_4T:0.8), (bad-artist-anime:0.7),(deformed iris, deformed pupils, bad eyes, semi-realistic:1.4), (worst quality, low quality:1.3), (blurry:1.2), (greyscale, monochrome:1.1), (poorly drawn face), cloned face, cross eyed , extra fingers, mutated hands, (fused fingers), (too many fingers), (missing arms), (missing legs), (extra arms), (extra legs), (poorly drawn hands), (bad anatomy), (bad proportions), cropped, lowres, text, jpeg artifacts, signature, watermark, username, artist name, trademark, watermark, title, multiple view, Reference sheet, long neck, Out of Frame,(Naked, Nude, NSFW, Erotica:2.0), tall trees, floating, floating trees, cartoon, 2d, 3d, duplicates, duplicate, same 迭代步数50 采样方法DPM++ 2M SDE Karras 宽度 高度1024 768 随机种子-1 ADetailer ControlNet v1.1.206完美像素模式 模型 control_v1p_sd15_qrcode_monster [a6e58995] 缩放并填充"},{"title":"Pandorabox之透明代理","permalink":"https://yzy666699.github.io/2017/02/07/Pandorabox-transparent-proxy/","text":"先修改Lan接口，避免在无线中继的时候发生本地Lan接口与wwan接口发生冲突导致无法登陆路由器。 网络 -&gt; Lan -&gt; IPv4地址， 设置为 192.168.33.1更改之后需要重新连接一下网络。 透明代理使用shadowsocks-libev和ChinDNS实现。使用ssh登陆路由器，安装所需软件。 123ssh root@192.168.33.1opkg updateopkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum 这个版本的软件源有点问题，所以直接opkg install基本上都过不了sha256sum检测，所以需要加上--force-checksum参数强制忽略。两个luci界面都有zh-cn汉化包，为了节省路由器空间，就不装了。 默认的chnroute表很老了，需要更新： 1234mv /etc/chnroute.txt /etc/chnroute.txt.bakwget -O- &#x27;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&#x27; | awk -F\\| &#x27;/CN\\|ipv4/ &#123; printf(&quot;%s/%d\\n&quot;, $4, 32-log($5)/log(2)) &#125;&#x27; &gt; /etc/chnroute.txt# 如果没有问题rm -rf /etc/chnroute.txt.bak 然后我们需要对其进行启用。 shadowsocks需要启动ss-redir来实现透明代理和ss-tunnel来实现UDP转发保证国外DNS查询不被污染。下面是具体需要注意的配置。 SS-tunnel1234&#123; &quot;UDP Local Port&quot;: 1153, &quot;Forwarding Tunnel&quot;: 8.8.8.8:53&#125; ChinaDNS123456&#123; &quot;Enable DNS compression pointer&quot;: true, &quot;Local Port&quot;: 1053, //不能与ss-tunnel冲突 &quot;CHNRoute File&quot;: &quot;/etc/chnroute.txt&quot;, &quot;Upstream Servers&quot;: &quot;223.5.5.5,127.0.0.1:1153&quot; //第一个是国内阿里DNS服务器，第二个是进过ss-tunnel转发后的Google DNS服务器&#125; DHCP&#x2F;DNS最后需要在网络-&gt;DHCP/DNS-&gt;服务器设置修改默认的DNS配置 1234&#123; &quot;本地服务器&quot;: &quot;127.0.0.1#1053&quot;, //ChinaDNS处理后的DNS服务器，可以根据ip分流。 &quot;忽略解析文件&quot;: true&#125; 总的来说，GoogleDNS(8.8.8.8:53)首先进过ss-tunnel转发到本地的127.0.0.1:1153上，然后通过ChinaDNS与国内DNS服务器融合成新的127.0.0.1:1053 实现了国内外分流。 Update由于实用过程中还是经常不稳定，决定采用DNS-Forwarder方案。然而，官方并没有我的小米Mini路由架构的二进制包，只能自己动手丰衣足食了。 OpenWrt SDK首先明确小米路由器Mini的架构是ramips&#x2F;mt7620a而现在运行的Pandorabox 16.10基于Openwrt Barrier Breaker。 依赖1sudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzip gawk zlib1g-dev subversion mercurial 下载&amp;编译12345curl https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/OpenWrt-SDK-ramips-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2 | tar -xjf cd OpenWrt-SDK-*git clone https://github.com/aa65535/openwrt-dns-forwarder.git package/dns-forwarder # 获取Makefilemake menuconfig # 选择要编译的包： Network -&gt; dns-forwardermake package/dns-forwarder/compile V=99 然而，愿景很好，但是在我的Deepin上make menuconfig这步就出错，想想barrier_breaker也是很久之前的版本了，出错大概是ldxxxx，感觉应该是GCC版本不兼容的缘故，然而Deepin上GCC只有6.2.0没有官方要求的4.8，怎么办呢？当时暂时想到下面几条解决方案 在自己电脑上重新编译一份GCC4.8： 太麻烦，而且还不能保证一定能成功。 用虚拟机装老版本的Ubuntu： 太浪费时间了，本身电脑BIOS就没有开启虚拟化支持。 docker? 不错可以试一下。 docker运行老版本ubuntu镜像不用太简单，一条命令搞定： 1sudo docker run -t -i ubuntu:12.04.5 /bin/bash 然而docker版本的ubuntu太过于精简了,需要配置一下： 123456# 安装缺失依赖apt-get install ccache curl# openwrt-sdk 编译不能以root用户进行，需要新建一个普通用户useradd kevinsu kevin# 继续之前的编译步骤 好了，终于编译成功了，然而还是高兴的太早，仍然报错： 1* pkg_hash_fetch_best_installation_candidate: Packages for helloworld found, but incompatible with the architectures configured 还是求助于Google，然后发现了这篇博客：小米路由器mini折腾之配置opkg篇，于是我的路由器就成砖了。hhhhhhhhh 未完待续。。。。。。。。。。。。。。 2017-8-15 update拿去店里救砖成功。刷了不死breed，但是现在反而没有什么折腾劲了。"}],"categories":[],"tags":[]}