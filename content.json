{"pages":[{"title":"About me","permalink":"http://keyin.me/about/index.html","text":"Binary Security researcher and malware development enthusiast C &#x2F;C艹 Java Go Telegram: @DB_Cooper_me Github： Y2Y Twttier: X Mail: &#121;&#122;&#121;&#x36;&#x36;&#x36;&#54;&#57;&#57;&#x40;&#x67;&#x6d;&#105;&#97;&#x6c;&#x2e;&#x63;&#111;&#x6d;"}],"posts":[{"title":"逆向分析","permalink":"http://keyin.me/2023/07/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","text":"逆向分析记一次对勒索病毒的分析知识记录在PE（Portable Executable，可移植可执行）文件格式中，各种数据结构和表都是通过偏移量来访问的。特定的偏移量，如60和120，通常与PE文件的标准布局有关。具体来说： PE文件头结构：PE文件由MS-DOS头、PE文件头（包括COFF文件头和可选头）以及节（Sections）组成。PE头后面紧跟的是节表（Sections table），它描述了文件中各个节的位置和特性。 60偏移量：在PE文件中，从文件开始到PE标志的偏移量存储在MS-DOS头的0x3C位置（十进制为60）。这是一个指向PE头的指针。通过读取这个偏移量并加上基地址，可以定位到PE头的开始。 120偏移量：在可选头中，DataDirectory是一个数组，它提供了关于各种表和数据结构（如导入表、导出表、资源表等）的信息。DataDirectory的第一个元素（索引为0）是导出表的入口，而DataDirectory本身在可选头的开始处有一个偏移量。在标准的PE格式中，DataDirectory数组距离PE头的开始有0x78（十进制120）字节的偏移。 所以，当你看到这样的代码： 1234.text:004068F1 mov ecx, [edi+3Ch].text:004068F4 and esi, 1FFFFFh.text:004068FA xor ebx, ebx.text:004068FC mov ecx, [ecx+edi+78h] 1v14 + *(_DWORD *)(*(_DWORD *)(v14 + 60) + v14 + 120) 这里的操作可以这样理解： v14代表加载到内存中的PE文件的基地址。 v14 + 60是获取到PE头的偏移量。 *(_DWORD *)(v14 + 60)读取该偏移量，得到PE头的实际地址。 在PE头的基础上加上120，即可定位到DataDirectory。 最终，这段代码访问了PE文件中的某个特定DataDirectory入口（很可能是导出表），然后通过这个入口来获取其他信息或进行进一步的操作。 如果逆向时突然出现两次循环且每次循环次数都为256，后续存在异或操作基本可以猜测为rc4解密算法，这种特性为rc4算法特征 记一次BYOYD驱动分析首先直接定位到驱动的IRP_MJ_DEVICE_CONTROL(14)分发例程函数位置： a2-&gt;Tail.Overlay.CurrentStackLocation其实就是IoGetCurrentIrpStackLocation()函数的实现。 正常是通过stack-&gt;Parameters.DeviceIoControl.IoControlCode 来获取IOCTL值的，反编译这里是通过 CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart 获取，姑且当做是同一个意思。 alt+Y切换联合体 a2-&gt;AssociatedIrp.MasterIrp 其实是a2-&gt;AssociatedIrp.SystemBuffer（输入缓冲区的地址），因为它俩在一个union 中，共享一个偏移量。 MasterIrp-&gt;Type 其实就是SystemBuffer 这个缓冲区（0x9E6A0594 代表这是一个缓冲IO），因为这里Type它的偏移其实是0。MasterIrp-&gt;MdlAddress这里的MdlAddress偏移是8，是一个长度（从sub_1400012BC函数内部看出来的），这个由客户端程序构造。 dword_14000410C是一个全局变量（在.data段），它的值是当前进程的PID，在sub_1400012BC函数中赋予。所以，我们要想走到下面的流程，必须要先完成0x9E6A0594 这个IOCTL的操作。 接下来看下面几个IOCTL对应的代码逻辑： 0xE6224248 这个IOCTL代码下面，可以见到是根据PID获取句柄，然后添加到I&#x2F;O缓冲区后面。此部分逻辑和内存读取无关。 0x60A26124 这块的代码逻辑，首先是从I&#x2F;O缓冲区中获取进程句柄。然后利用ObReferenceObjectByHandle 函数获取此句柄对应的EPROCESS结构，最后调用sub_140001B80函数。在这个函数中，发现了MmCopyVirtualMemory 虚拟内存拷贝函数。 接下来就是弄清楚，这个5个参数是如何组织的： 这里rdi寄存器中保存的是I&#x2F;O缓冲区的地址。结合上两张图I&#x2F;O缓冲区中的数据可以构成如下结构： 1234567struct&#123;HANDLE ProcessHander;INT64 SourceAddr;INT64 TargetAddr;SIZE_T Size;SIZE_T Result;&#125; 注意这里MmCopyVirtualMemory 函数的SourceProcess和TargetProcess都一样为当前进程的EPROCESS。所以这里SourceAddr和TargetAddr互换就可以实现读写效果。 记一次堆外挂的分析查壳Patch ida由于ida不支持中文名称命名，先patch掉中文函数名称支持 去除合法字符检测 ：合法字符的定义在ida.cfg文件中，我们定位到文件，搜索Block_CJK_Unified_Ideographs。注释掉即可 接触ida反汇编中文限制 过对IDA进行逆向得知，原来hexray在生成伪代码的时候会调用一个calc_c_cpp_name函数，该函数会试图针对C&#x2F;C++的函数名称进行优化，结果却误伤中文字符，我们将此处代码给NOP掉，就可以了。 采用插件分析易语言特征dump数据 手动搜索 4d 5a 90 搜索到两个pe特征 dump出数据 ​ 易语言开发通常会把PE文件当作图片资源存放在易语言资源里面，而资源的数据区上面的DWORD就是数据大小 按这个规律可以直接dump出两个PE文件 菜单栏中选择：edit–&gt;array，就会弹出如下的转换为数组，数组大小写入0x8660 菜单栏选择：edit-&gt;export data 选择raw格式 dump出的数据 dump1.sys 逆向 拖入ida分析，查看是标准的wdf驱动 360 驱动逆向360文FsFlt.sys件系统过滤驱动"},{"title":"静态软件分析","permalink":"http://keyin.me/2023/05/06/%E9%9D%99%E6%80%81%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/","text":"静态软件分析part 0x01 Introductionadditionvalue不断的认识自己，发掘自己，明白什么东西使自己快乐起来，什么东西愿意花时间去搞，思考 security amply污点分析&#x2F;信息流分析&#x2F;数据流分析&#x2F;控制流分析&#x2F;过程间分析&#x2F;指针分析&#x2F;别名分析&#x2F;符号执行 内存泄露和空指针引用：如果一个指针被错误地使用（例如，被设为 null 或者指向已经释放的内存），程序可能会崩溃或者产生未定义的行为。指针分析可以帮助检测这类错误。 缓冲区溢出：如果一个指针被用来写入超过了预分配的内存区域，就可能导致缓冲区溢出，这是一种常见的安全漏洞。通过对指针的使用进行分析，我们可以找出可能的缓冲区溢出。 未授权的内存访问：如果一个指针被用来访问不应该被访问的内存区域（例如，其他用户的数据或者敏感的系统资源），这可能是一个安全问题。指针分析可以帮助我们发现这样的问题。 数据竞态条件：如果多个线程或者进程共享一段内存，并且对这段内存的访问没有被正确地同步，可能会导致数据竞态条件，这也是一种常见的安全问题。通过指针分析，我们可以确定哪些内存区域被多个线程或者进程共享，从而帮助我们找出可能的数据竞态条件。 part 0x02 Control Flow Graphspart 0x03 Data Flow Analysis迭代算法"},{"title":"Pandorabox之透明代理","permalink":"http://keyin.me/2017/02/07/Pandorabox-transparent-proxy/","text":"先修改Lan接口，避免在无线中继的时候发生本地Lan接口与wwan接口发生冲突导致无法登陆路由器。 网络 -&gt; Lan -&gt; IPv4地址， 设置为 192.168.33.1更改之后需要重新连接一下网络。 透明代理使用shadowsocks-libev和ChinDNS实现。使用ssh登陆路由器，安装所需软件。 123ssh root@192.168.33.1opkg updateopkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum 这个版本的软件源有点问题，所以直接opkg install基本上都过不了sha256sum检测，所以需要加上--force-checksum参数强制忽略。两个luci界面都有zh-cn汉化包，为了节省路由器空间，就不装了。 默认的chnroute表很老了，需要更新： 1234mv /etc/chnroute.txt /etc/chnroute.txt.bakwget -O- &#x27;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&#x27; | awk -F\\| &#x27;/CN\\|ipv4/ &#123; printf(&quot;%s/%d\\n&quot;, $4, 32-log($5)/log(2)) &#125;&#x27; &gt; /etc/chnroute.txt# 如果没有问题rm -rf /etc/chnroute.txt.bak 然后我们需要对其进行启用。 shadowsocks需要启动ss-redir来实现透明代理和ss-tunnel来实现UDP转发保证国外DNS查询不被污染。下面是具体需要注意的配置。 SS-tunnel1234&#123; &quot;UDP Local Port&quot;: 1153, &quot;Forwarding Tunnel&quot;: 8.8.8.8:53&#125; ChinaDNS123456&#123; &quot;Enable DNS compression pointer&quot;: true, &quot;Local Port&quot;: 1053, //不能与ss-tunnel冲突 &quot;CHNRoute File&quot;: &quot;/etc/chnroute.txt&quot;, &quot;Upstream Servers&quot;: &quot;223.5.5.5,127.0.0.1:1153&quot; //第一个是国内阿里DNS服务器，第二个是进过ss-tunnel转发后的Google DNS服务器&#125; DHCP&#x2F;DNS最后需要在网络-&gt;DHCP/DNS-&gt;服务器设置修改默认的DNS配置 1234&#123; &quot;本地服务器&quot;: &quot;127.0.0.1#1053&quot;, //ChinaDNS处理后的DNS服务器，可以根据ip分流。 &quot;忽略解析文件&quot;: true&#125; 总的来说，GoogleDNS(8.8.8.8:53)首先进过ss-tunnel转发到本地的127.0.0.1:1153上，然后通过ChinaDNS与国内DNS服务器融合成新的127.0.0.1:1053 实现了国内外分流。 Update由于实用过程中还是经常不稳定，决定采用DNS-Forwarder方案。然而，官方并没有我的小米Mini路由架构的二进制包，只能自己动手丰衣足食了。 OpenWrt SDK首先明确小米路由器Mini的架构是ramips&#x2F;mt7620a而现在运行的Pandorabox 16.10基于Openwrt Barrier Breaker。 依赖1sudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzip gawk zlib1g-dev subversion mercurial 下载&amp;编译12345curl https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/OpenWrt-SDK-ramips-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2 | tar -xjf cd OpenWrt-SDK-*git clone https://github.com/aa65535/openwrt-dns-forwarder.git package/dns-forwarder # 获取Makefilemake menuconfig # 选择要编译的包： Network -&gt; dns-forwardermake package/dns-forwarder/compile V=99 然而，愿景很好，但是在我的Deepin上make menuconfig这步就出错，想想barrier_breaker也是很久之前的版本了，出错大概是ldxxxx，感觉应该是GCC版本不兼容的缘故，然而Deepin上GCC只有6.2.0没有官方要求的4.8，怎么办呢？当时暂时想到下面几条解决方案 在自己电脑上重新编译一份GCC4.8： 太麻烦，而且还不能保证一定能成功。 用虚拟机装老版本的Ubuntu： 太浪费时间了，本身电脑BIOS就没有开启虚拟化支持。 docker? 不错可以试一下。 docker运行老版本ubuntu镜像不用太简单，一条命令搞定： 1sudo docker run -t -i ubuntu:12.04.5 /bin/bash 然而docker版本的ubuntu太过于精简了,需要配置一下： 123456# 安装缺失依赖apt-get install ccache curl# openwrt-sdk 编译不能以root用户进行，需要新建一个普通用户useradd kevinsu kevin# 继续之前的编译步骤 好了，终于编译成功了，然而还是高兴的太早，仍然报错： 1* pkg_hash_fetch_best_installation_candidate: Packages for helloworld found, but incompatible with the architectures configured 还是求助于Google，然后发现了这篇博客：小米路由器mini折腾之配置opkg篇，于是我的路由器就成砖了。hhhhhhhhh 未完待续。。。。。。。。。。。。。。 2017-8-15 update拿去店里救砖成功。刷了不死breed，但是现在反而没有什么折腾劲了。"}],"categories":[],"tags":[]}