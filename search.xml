<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆向分析</title>
      <link href="/2023/07/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
      <url>/2023/07/08/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="记一次对勒索病毒的分析"><a href="#记一次对勒索病毒的分析" class="headerlink" title="记一次对勒索病毒的分析"></a>记一次对勒索病毒的分析</h2><h3 id="知识汇总"><a href="#知识汇总" class="headerlink" title="知识汇总"></a>知识汇总</h3><p>在PE（Portable Executable，可移植可执行）文件格式中，各种数据结构和表都是通过偏移量来访问的。特定的偏移量，如60和120，通常与PE文件的标准布局有关。具体来说：</p><span id="more"></span><ul><li><strong>PE文件头结构</strong>：PE文件由MS-DOS头、PE文件头（包括COFF文件头和可选头）以及节（Sections）组成。PE头后面紧跟的是节表（Sections table），它描述了文件中各个节的位置和特性。</li><li><strong><code>60</code>偏移量</strong>：在PE文件中，从文件开始到<code>PE</code>标志的偏移量存储在MS-DOS头的<code>0x3C</code>位置（十进制为60）。这是一个指向PE头的指针。通过读取这个偏移量并加上基地址，可以定位到PE头的开始。</li><li><strong><code>120</code>偏移量</strong>：在可选头中，<code>DataDirectory</code>是一个数组，它提供了关于各种表和数据结构（如导入表、导出表、资源表等）的信息。<code>DataDirectory</code>的第一个元素（索引为0）是导出表的入口，而<code>DataDirectory</code>本身在可选头的开始处有一个偏移量。在标准的PE格式中，<code>DataDirectory</code>数组距离PE头的开始有<code>0x78</code>（十进制120）字节的偏移。</li></ul><p>所以，当你看到这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:004068F1                 mov     ecx, [edi+3Ch]</span><br><span class="line">.text:004068F4                 and     esi, 1FFFFFh</span><br><span class="line">.text:004068FA                 xor     ebx, ebx</span><br><span class="line">.text:004068FC                 mov     ecx, [ecx+edi+78h]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v14 + *(_DWORD *)(*(_DWORD *)(v14 + <span class="number">60</span>) + v14 + <span class="number">120</span>)</span><br></pre></td></tr></table></figure><p>这里的操作可以这样理解：</p><ol><li><code>v14</code>代表加载到内存中的PE文件的基地址。</li><li><code>v14 + 60</code>是获取到PE头的偏移量。</li><li><code>*(_DWORD *)(v14 + 60)</code>读取该偏移量，得到PE头的实际地址。</li><li>在PE头的基础上加上<code>120</code>，即可定位到<code>DataDirectory</code>。</li><li>最终，这段代码访问了PE文件中的某个特定<code>DataDirectory</code>入口（很可能是导出表），然后通过这个入口来获取其他信息或进行进一步的操作。</li></ol><p><strong>如果逆向时突然出现两次循环且每次循环次数都为256，后续存在异或操作基本可以猜测为rc4解密算法，这种特性为rc4算法特征</strong></p><p><img src="https://i.imgur.com/21pbopR.png" alt="784955_Q4TARCJCEH7P6BT"></p><h2 id="记一次BYOYD驱动分析"><a href="#记一次BYOYD驱动分析" class="headerlink" title="记一次BYOYD驱动分析"></a>记一次BYOYD驱动分析</h2><p>首先直接定位到驱动的<code>IRP_MJ_DEVICE_CONTROL(14)</code>分发例程函数位置：</p><p><img src="https://i.imgur.com/9lSDpA6.jpeg" alt="图片"></p><ol><li><p><code>a2-&gt;Tail.Overlay.CurrentStackLocation</code>其实就是<code>IoGetCurrentIrpStackLocation()</code>函数的实现。</p></li><li><p>正常是通过<code>stack-&gt;Parameters.DeviceIoControl.IoControlCode </code>来获取IOCTL值的，反编译这里是通过</p><p><code>CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart</code> 获取，姑且当做是同一个意思。 <code>alt+Y</code>切换联合体</p></li><li><p><code>a2-&gt;AssociatedIrp.MasterIrp</code> 其实是<code>a2-&gt;AssociatedIrp.SystemBuffer</code>（输入缓冲区的地址），因为它俩在一个<code>union </code>中，共享一个偏移量。</p><p><img src="https://i.imgur.com/uNqrVk6.jpeg" alt="图片"></p><p><strong>Associatedlrp.SystemBuffer</strong>: SystemBuffer指针指向一个数据缓冲区，该缓冲区位于内核模式的非分<br>页内存中I&#x2F;O管理器把用户模式程序发送给驱动程序的数据复制到这个缓冲区，这也是创建IRP过程的一部<br>分。对于读请求，设备驱动程序把读出的数据填到这个缓冲区，然后I&#x2F;O管理器再把缓浊区的内容复制到<br>用户模式缓冲区。</p></li><li><p><code>MasterIrp-&gt;Type</code> 其实就是SystemBuffer 这个缓冲区（0x9E6A0594 代表这是一个缓冲IO），因为这里Type它的偏移其实是0。<code>MasterIrp-&gt;MdlAddress</code>这里的MdlAddress偏移是8，是一个长度（从sub_1400012BC函数内部看出来的），这个由客户端程序构造。</p></li><li><p><code>dword_14000410C</code>是一个全局变量（在.data段），它的值是当前进程的PID，在<code>sub_1400012BC</code>函数中赋予。所以，我们要想走到下面的流程，必须要先完成0x9E6A0594 这个IOCTL的操作。</p><p><img src="https://i.imgur.com/ZyVoRrk.jpeg" alt="图片"></p></li></ol><p>接下来看下面几个IOCTL对应的代码逻辑：</p><p><img src="https://i.imgur.com/F5cfAL1.jpeg" alt="图片"></p><ol><li><p><code>0xE6224248</code> 这个IOCTL代码下面，可以见到是根据PID获取句柄，然后添加到I&#x2F;O缓冲区后面。此部分逻辑和内存读取无关。</p></li><li><p><code>0x60A26124 </code>这块的代码逻辑，首先是从I&#x2F;O缓冲区中获取进程句柄。然后利用<code>ObReferenceObjectByHandle </code>函数获取此句柄对应的<code>EPROCESS</code>结构，最后调用<code>sub_140001B80</code>函数。在这个函数中，发现了<code>MmCopyVirtualMemory</code> 虚拟内存拷贝函数。</p><p><img src="https://i.imgur.com/iEuGKgX.jpeg" alt="图片"></p></li></ol><p>接下来就是弄清楚，这个5个参数是如何组织的：</p><p><img src="https://i.imgur.com/FHVlzwX.jpeg" alt="图片"></p><p>这里<code>rdi</code>寄存器中保存的是I&#x2F;O缓冲区的地址。结合上两张图I&#x2F;O缓冲区中的数据可以构成如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">HANDLE ProcessHander;</span><br><span class="line">INT64 SourceAddr;</span><br><span class="line">INT64 TargetAddr;</span><br><span class="line">SIZE_T Size;</span><br><span class="line">SIZE_T Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里MmCopyVirtualMemory 函数的SourceProcess和TargetProcess都一样为当前进程的EPROCESS。所以这里SourceAddr和TargetAddr互换就可以实现读写效果。</p><h2 id="记一次堆外挂的分析"><a href="#记一次堆外挂的分析" class="headerlink" title="记一次堆外挂的分析"></a>记一次堆外挂的分析</h2><h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><h3 id="Patch-ida"><a href="#Patch-ida" class="headerlink" title="Patch ida"></a>Patch ida</h3><p>由于ida不支持中文名称命名，先patch掉中文函数名称支持</p><ol><li><p>去除合法字符检测 ：合法字符的定义在ida.cfg文件中，我们定位到文件，搜索Block_CJK_Unified_Ideographs。注释掉即可</p></li><li><p>接触ida反汇编中文限制</p><p>过对IDA进行逆向得知，原来hexray在生成伪代码的时候会调用一个<code>calc_c_cpp_name</code>函数，该函数会试图针对C&#x2F;C++的函数名称进行优化，结果却误伤中文字符，我们将此处代码给NOP掉，就可以了。</p><p><img src="https://i.imgur.com/SLOyGM3.jpeg" alt="image-20240402105902157"></p></li></ol><h3 id="采用插件分析易语言特征"><a href="#采用插件分析易语言特征" class="headerlink" title="采用插件分析易语言特征"></a>采用插件分析易语言特征</h3><h3 id="dump数据"><a href="#dump数据" class="headerlink" title="dump数据"></a>dump数据</h3><ul><li><p>手动搜索 <code>4d 5a 90</code> 搜索到两个pe特征</p><p><img src="https://i.imgur.com/cyF3bp9.png" alt="image-20240402105840502"></p></li><li><p>dump出数据</p></li></ul><p>​易语言开发通常会把PE文件当作图片资源存放在易语言资源里面，而资源的数据区上面的DWORD就是数据大小</p><p><img src="https://i.imgur.com/Z5IMSvR.png" alt="image-20240402110040651"></p><p>按这个规律可以直接dump出两个PE文件</p><p>菜单栏中选择：edit–&gt;array，就会弹出如下的转换为数组，数组大小写入0x8660</p><p><img src="https://i.imgur.com/QIrPpxU.png" alt="image-20240402110426617"></p><p>菜单栏选择：edit-&gt;export data 选择raw格式</p><p>dump出的数据</p><p><img src="https://i.imgur.com/W6XbKum.png" alt="image-20240402111325403"></p><h3 id="dump1-sys-逆向"><a href="#dump1-sys-逆向" class="headerlink" title="dump1.sys 逆向"></a>dump1.sys 逆向</h3><ol><li>拖入ida分析，查看是标准的wdf驱动</li><li>分析<code>IRP_MJ_DEVICE_CONTROL(14)</code></li></ol><h2 id="360-驱动逆向"><a href="#360-驱动逆向" class="headerlink" title="360 驱动逆向"></a>360 驱动逆向</h2><h3 id="360文FsFlt-sys件系统过滤驱动"><a href="#360文FsFlt-sys件系统过滤驱动" class="headerlink" title="360文FsFlt.sys件系统过滤驱动"></a>360文FsFlt.sys件系统过滤驱动</h3>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态软件分析</title>
      <link href="/2023/05/06/%E9%9D%99%E6%80%81%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/06/%E9%9D%99%E6%80%81%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="静态软件分析"><a href="#静态软件分析" class="headerlink" title="静态软件分析"></a>静态软件分析</h1><h2 id="part-0x01-Introduction"><a href="#part-0x01-Introduction" class="headerlink" title="part 0x01 Introduction"></a>part 0x01 Introduction</h2><h3 id="additionvalue"><a href="#additionvalue" class="headerlink" title="additionvalue"></a>additionvalue</h3><p>不断的认识自己，发掘自己，明白什么东西使自己快乐起来，什么东西愿意花时间去搞，思考</p><h3 id="security-amply"><a href="#security-amply" class="headerlink" title="security amply"></a>security amply</h3><p><strong>污点分析&#x2F;信息流分析&#x2F;数据流分析&#x2F;控制流分析&#x2F;过程间分析&#x2F;指针分析&#x2F;别名分析&#x2F;符号执行</strong></p><ol><li><p><strong>内存泄露和空指针引用</strong>：如果一个指针被错误地使用（例如，被设为 null 或者指向已经释放的内存），程序可能会崩溃或者产生未定义的行为。指针分析可以帮助检测这类错误。</p></li><li><p><strong>缓冲区溢出</strong>：如果一个指针被用来写入超过了预分配的内存区域，就可能导致缓冲区溢出，这是一种常见的安全漏洞。通过对指针的使用进行分析，我们可以找出可能的缓冲区溢出。</p></li><li><p><strong>未授权的内存访问</strong>：如果一个指针被用来访问不应该被访问的内存区域（例如，其他用户的数据或者敏感的系统资源），这可能是一个安全问题。指针分析可以帮助我们发现这样的问题。</p></li><li><p><strong>数据竞态条件</strong>：如果多个线程或者进程共享一段内存，并且对这段内存的访问没有被正确地同步，可能会导致数据竞态条件，这也是一种常见的安全问题。通过指针分析，我们可以确定哪些内存区域被多个线程或者进程共享，从而帮助我们找出可能的数据竞态条件。</p></li></ol><span id="more"></span><p>fsadfsdf</p><ul><li><p>PL分支</p><p><img src="/images/context/PL.png" alt="PL"></p></li><li><p>语言的分类：命令式 (C, Java)、函数式 (Haskell)、逻辑式&#x2F;声明式</p></li><li><p>挑战：语言没有变，但是程序变复杂了，如何保证可靠</p></li><li><p>静态分析的用途：程序可靠性、程序安全、编译优化、程序理解</p></li></ul><h3 id="Static-Analysis-静态分析"><a href="#Static-Analysis-静态分析" class="headerlink" title="Static Analysis 静态分析"></a>Static Analysis 静态分析</h3><ul><li><p>静态分析：<strong>Static analysis</strong> analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P.</p></li><li><p>一句话概括静态分析：Static Analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed. 在保证正确性的前提下，在精度和速度上做平衡。</p></li><li><p>两个词概括静态分析</p><ul><li><strong>useful static analysis</strong>: 具体值-&gt;符号值</li></ul><p><img src="/images/context/abstraction.png" alt="abstraction"></p><ul><li><p><strong>useful static analysis</strong></p><ul><li>Transfer functions: 抽象值上的操作</li></ul><p>![teansfer function](&#x2F;images&#x2F;context&#x2F;teansfer function.png)</p><ul><li>Control flows</li></ul><p>![contril flows](&#x2F;images&#x2F;context&#x2F;contril flows.png)</p></li></ul></li></ul><h3 id="sound-complete"><a href="#sound-complete" class="headerlink" title="sound &amp; complete"></a>sound &amp; complete</h3><ul><li><p><strong>Rice’s Theorem</strong> : Any non-trivial property of the behavior of programs in a r.e. language is undecidable.</p><ul><li>non-trivial properties ~&#x3D; interesting properties ~&#x3D; the properties related with run-time behaviors of programs</li><li>r.e. (recursively enumerable) 递归可枚举语言: recognizable by a Turing-machine</li><li>There is no such approach to determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No</li><li>故不存在 perfect (sound &amp; complete) static analysis</li></ul></li><li><p><strong>useful static analysis</strong></p><ul><li>Over- and under-approximations are both for safety of analysis</li><li>sound: 报出所有问题 may analysis: outputs information that may be true (over-approximation) (safe&#x3D;over)</li><li>complete: 报出的问题都是对的 must analysis: outputs information that must be true (under-approximation) (safe&#x3D;under)</li></ul><p><img src="/images/context/sound.png" alt="sound"></p></li><li><p><strong>useful static analysis</strong></p><p><img src="/images/context/useful.png" alt="useful"></p><ul><li>妥协 soundness (false negatives 可能漏报)</li><li>妥协 completeness (false positives 可能误报) (大多数情况的分析，因为 soundness 很重要)</li></ul></li></ul><h2 id="part-0x02-Control-Flow-Graphs"><a href="#part-0x02-Control-Flow-Graphs" class="headerlink" title="part 0x02 Control Flow Graphs"></a>part 0x02 Control Flow Graphs</h2><h2 id="part-0x03-Data-Flow-Analysis"><a href="#part-0x03-Data-Flow-Analysis" class="headerlink" title="part 0x03 Data Flow Analysis"></a>part 0x03 Data Flow Analysis</h2><p>迭代算法</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Analusis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI制作图片二维码</title>
      <link href="/2022/08/11/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/08/11/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="AI制作图片二维码"><a href="#AI制作图片二维码" class="headerlink" title="AI制作图片二维码"></a>AI制作图片二维码</h1><h2 id="二维码解析"><a href="#二维码解析" class="headerlink" title="二维码解析"></a>二维码解析</h2><p>将二维码转换成矢量图，并采用在线网站进行二维码解析</p><span id="more"></span><h3 id="二维码生成矢量图"><a href="#二维码生成矢量图" class="headerlink" title="二维码生成矢量图"></a>二维码生成矢量图</h3><p><a href="https://qrcode.antfu.me/">https://qrcode.antfu.me/</a></p><p>进行参数调节</p><p><img src="https://i.imgur.com/vCLQto7.png" alt="image-20230730000316244"></p><h2 id="ssh连接webui"><a href="#ssh连接webui" class="headerlink" title="ssh连接webui"></a>ssh连接webui</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CNg -L 6006:127.0.0.1:6006 root@222.187.226.110 -p 31146</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/o70iIhv.png" alt="image-20230730002459085"></p><h3 id="二维码webui生成"><a href="#二维码webui生成" class="headerlink" title="二维码webui生成"></a>二维码webui生成</h3><h3 id="主模型"><a href="#主模型" class="headerlink" title="主模型"></a>主模型</h3><p>revAnimated</p><h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><h4 id="风景"><a href="#风景" class="headerlink" title="风景"></a>风景</h4><p>正向词</p><p>british columbia, surrounded by mountains and nature, beautiful lakes and rivers, northern lights, volumetric lighting, photorealistic, insanely detailed and intricate, canadian rocky mountains, 8k ultra hd, matte painting, night time, Sweeper3D, Ultra realistic, (35mm style:1. 1), ((best quality)), ((masterpiece)), ((realistic)), radiant light rays, highres, highly detailed, concept art, Exaggeration, Aesthetic, magazine, Backlight, light color , heavenly, shadowy, Realism, octane render, unreal engine 5, Shaders, Denoise, De-Noise, Ambient Occlusion</p><p>反向词</p><p>(bad-image-v2-39000:0.8), (bad_prompt_version2:0.8), (bad-hands-5:1.1), (EasyNegative:0.8), (NG_DeepNegative_V1_4T:0.8), (bad-artist-anime:0.7),(deformed iris, deformed pupils, bad eyes, semi-realistic:1.4), (worst quality, low quality:1.3), (blurry:1.2), (greyscale, monochrome:1.1), (poorly drawn face), cloned face, cross eyed , extra fingers, mutated hands, (fused fingers), (too many fingers), (missing arms), (missing legs), (extra arms), (extra legs), (poorly drawn hands), (bad anatomy), (bad proportions), cropped, lowres, text, jpeg artifacts, signature, watermark, username, artist name, trademark, watermark, title, multiple view, Reference sheet, long neck, Out of Frame,(Naked, Nude, NSFW, Erotica:2.0), tall trees, floating, floating trees, cartoon, 2d, 3d, duplicates, duplicate, same</p><h3 id="迭代步数"><a href="#迭代步数" class="headerlink" title="迭代步数"></a>迭代步数</h3><p>50</p><h3 id="采样方法"><a href="#采样方法" class="headerlink" title="采样方法"></a>采样方法</h3><p>DPM++ 2M SDE Karras</p><h3 id="宽度-高度"><a href="#宽度-高度" class="headerlink" title="宽度 高度"></a>宽度 高度</h3><p>1024 768</p><h3 id="随机种子"><a href="#随机种子" class="headerlink" title="随机种子"></a>随机种子</h3><p>-1</p><h3 id="ADetailer"><a href="#ADetailer" class="headerlink" title="ADetailer"></a>ADetailer</h3><p><img src="https://i.imgur.com/Ml1Ah3S.png" alt="image-20230730001243898"></p><h3 id="ControlNet-v1-1-206"><a href="#ControlNet-v1-1-206" class="headerlink" title="ControlNet v1.1.206"></a>ControlNet v1.1.206</h3><p>完美像素模式</p><p>模型 control_v1p_sd15_qrcode_monster [a6e58995]</p><p>缩放并填充</p><p><img src="https://i.imgur.com/0Gx5QTw.png" alt="image-20230730002150892"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandorabox之透明代理</title>
      <link href="/2017/02/07/Pandorabox-transparent-proxy/"/>
      <url>/2017/02/07/Pandorabox-transparent-proxy/</url>
      
        <content type="html"><![CDATA[<p>先修改Lan接口，避免在无线中继的时候发生本地Lan接口与wwan接口发生冲突导致无法登陆路由器。</p><p><code>网络 -&gt; Lan -&gt; IPv4地址， 设置为 192.168.33.1</code>更改之后需要重新连接一下网络。</p><p>透明代理使用<code>shadowsocks-libev</code>和<code>ChinDNS</code>实现。使用ssh登陆路由器，安装所需软件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.33.1</span><br><span class="line">opkg update</span><br><span class="line">opkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum</span><br></pre></td></tr></table></figure><p>这个版本的软件源有点问题，所以直接<code>opkg install</code>基本上都过不了<code>sha256sum</code>检测，所以需要加上<code>--force-checksum</code>参数强制忽略。两个luci界面都有zh-cn汉化包，为了节省路由器空间，就不装了。</p><span id="more"></span><p>默认的chnroute表很老了，需要更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/chnroute.txt /etc/chnroute.txt.bak</span><br><span class="line">wget -O- <span class="string">&#x27;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&#x27;</span> | awk -F\| <span class="string">&#x27;/CN\|ipv4/ &#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&#x27;</span> &gt; /etc/chnroute.txt</span><br><span class="line"><span class="comment"># 如果没有问题</span></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/chnroute.txt.bak</span><br></pre></td></tr></table></figure><p>然后我们需要对其进行启用。</p><p>shadowsocks需要启动<code>ss-redir</code>来实现透明代理和<code>ss-tunnel</code>来实现UDP转发保证国外DNS查询不被污染。下面是具体需要注意的配置。</p><h3 id="SS-tunnel"><a href="#SS-tunnel" class="headerlink" title="SS-tunnel"></a>SS-tunnel</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;UDP Local Port&quot;</span><span class="punctuation">:</span> <span class="number">1153</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Forwarding Tunnel&quot;</span><span class="punctuation">:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span><span class="punctuation">:</span><span class="number">53</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="ChinaDNS"><a href="#ChinaDNS" class="headerlink" title="ChinaDNS"></a>ChinaDNS</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Enable DNS compression pointer&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;Local Port&quot;</span>: <span class="number">1053</span>, <span class="comment">//不能与ss-tunnel冲突 </span></span><br><span class="line">  <span class="string">&quot;CHNRoute File&quot;</span>: <span class="string">&quot;/etc/chnroute.txt&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Upstream Servers&quot;</span>: <span class="string">&quot;223.5.5.5,127.0.0.1:1153&quot;</span> <span class="comment">//第一个是国内阿里DNS服务器，第二个是进过ss-tunnel转发后的Google DNS服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DHCP-DNS"><a href="#DHCP-DNS" class="headerlink" title="DHCP&#x2F;DNS"></a>DHCP&#x2F;DNS</h2><p>最后需要在<code>网络-&gt;DHCP/DNS-&gt;服务器设置</code>修改默认的DNS配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;本地服务器&quot;</span>: <span class="string">&quot;127.0.0.1#1053&quot;</span>, <span class="comment">//ChinaDNS处理后的DNS服务器，可以根据ip分流。</span></span><br><span class="line">  <span class="string">&quot;忽略解析文件&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，GoogleDNS(8.8.8.8:53)首先进过ss-tunnel转发到本地的<code>127.0.0.1:1153</code>上，然后通过ChinaDNS与国内DNS服务器融合成新的<code>127.0.0.1:1053</code> 实现了国内外分流。</p><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>由于实用过程中还是经常不稳定，决定采用DNS-Forwarder方案。<br>然而，官方并没有我的小米Mini路由架构的二进制包，只能自己动手丰衣足食了。</p><h3 id="OpenWrt-SDK"><a href="#OpenWrt-SDK" class="headerlink" title="OpenWrt SDK"></a>OpenWrt SDK</h3><p>首先明确小米路由器Mini的架构是ramips&#x2F;mt7620a而现在运行的Pandorabox 16.10基于Openwrt Barrier Breaker。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzip gawk zlib1g-dev subversion mercurial</span><br></pre></td></tr></table></figure><h3 id="下载-编译"><a href="#下载-编译" class="headerlink" title="下载&amp;编译"></a>下载&amp;编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/OpenWrt-SDK-ramips-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2 | tar -xjf </span><br><span class="line"><span class="built_in">cd</span> OpenWrt-SDK-*</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/aa65535/openwrt-dns-forwarder.git package/dns-forwarder <span class="comment"># 获取Makefile</span></span><br><span class="line">make menuconfig <span class="comment"># 选择要编译的包： Network -&gt; dns-forwarder</span></span><br><span class="line">make package/dns-forwarder/compile V=99</span><br></pre></td></tr></table></figure><p>然而，愿景很好，但是在我的Deepin上<code>make menuconfig</code>这步就出错，想想<code>barrier_breaker</code>也是很久之前的版本了，出错大概是<code>ldxxxx</code>，感觉应该是GCC版本不兼容的缘故，然而Deepin上GCC只有6.2.0没有官方要求的4.8，怎么办呢？当时暂时想到下面几条解决方案</p><ol><li>在自己电脑上重新编译一份GCC4.8： 太麻烦，而且还不能保证一定能成功。</li><li>用虚拟机装老版本的Ubuntu： 太浪费时间了，本身电脑BIOS就没有开启虚拟化支持。</li><li>docker? 不错可以试一下。</li></ol><p>docker运行老版本ubuntu镜像不用太简单，一条命令搞定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -t -i ubuntu:12.04.5 /bin/bash</span><br></pre></td></tr></table></figure><p>然而docker版本的ubuntu太过于精简了,需要配置一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装缺失依赖</span></span><br><span class="line">apt-get install ccache curl</span><br><span class="line"><span class="comment"># openwrt-sdk 编译不能以root用户进行，需要新建一个普通用户</span></span><br><span class="line">useradd kevin</span><br><span class="line">su kevin</span><br><span class="line"><span class="comment"># 继续之前的编译步骤</span></span><br></pre></td></tr></table></figure><p>好了，终于编译成功了，然而还是高兴的太早，仍然报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* pkg_hash_fetch_best_installation_candidate: Packages <span class="keyword">for</span> helloworld found, but incompatible with the architectures configured</span><br></pre></td></tr></table></figure><p>还是求助于Google，然后发现了这篇博客：<a href="https://blog.phpgao.com/xiaomi_router_opkg.html">小米路由器mini折腾之配置opkg篇</a>，于是我的路由器就成砖了。hhhhhhhhh</p><p>未完待续。。。。。。。。。。。。。。</p><h2 id="2017-8-15-update"><a href="#2017-8-15-update" class="headerlink" title="2017-8-15 update"></a>2017-8-15 update</h2><p>拿去店里救砖成功。刷了不死breed，但是现在反而没有什么折腾劲了。</p>]]></content>
      
      
      <categories>
          
          <category> Openwrt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由器 </tag>
            
            <tag> 科学上网 </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> ChinaDNS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
